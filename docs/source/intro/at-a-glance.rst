XFlash at a Glance
==================

Flash loans are a new type of loans that are made possible by the design of the Ethereum Virtual Machine (EVM). Imagine you can take out a loan, executes actions with the loan, and automatically enforce the repayment only if you can afford it. That is exactly what a flash loan allows you: if you have made successful arbitrage trade, or replaced your Maker CDP position with a different collateral asset you will be able to repay the loan. If you have made a loss executing your actions, the flash loan behaves as it would have never taken place. This makes it a risk-free loan for both the borrower and the lender.

XFlash extends the native capabilities of Ethereum to execute flash loans. Specifically, we enable lenders to lock assets on another chain, Bitcoin, and borrowers to take a loan against the locked Bitcoin on Ethereum. This way we:

* Enable cross-chain flash loans purely by locking asset on the backing-chain (Bitcoin)
* Remove the necessity to provide collateral for the backing of Bitcoin-backed tokens
* Build an entirely trustless system by utilizing SPV proofs

XFlash does *not* rely on any previously suggested backing mechanisms to bring BTC to Ethereum like XCLAIM, tBTC, wBTC, RenVM, or pTokens. Rather, XFlash relies on users keeping full custody over their tokens without involving third-parties (collateralized or other). Further, XFlash reduces the risk in the Ethereum smart contracts: a failure in the XFlash smart contracts can not lead to BTC being lost or stolen.

XFlash Protocols
================


Mint (Solo)
-----------

Pre-conditions
..............

Alice has 10 ``BTC`` on Bitcoin (i.e., locked in an UTXO controlled by her). Alice is identified by a public/private key pair :math:`pk_A, sk_A`. We assume, for simplicity, Alice uses the same key pair on both Bitcoin and Ethereum.
(Optional: Alice can specify an alternate key pair on Ethereum by (i) providing an `OP_RETURN` containing an Ethereum `account`, signed by `sk_A`)


Protocol
........

1. Alice locally generates a recovery secret :math:``r``. 

2. Alice creates a timelocked UTXO, locking 10 ``BTC`` for period :math:`t`, e.g., 24h, by broadcasting (and hence including) a transaction :math:`T_A` on Bitcoin. Thereby, Alice can recover her ``BTC`` at any time by revealing :math:``r``.
 
   * :math:`T_A` has at least one output ("payment UTXO"), which locks 10 ``BTC`` under the following condition: :math:`(\sigma_A \land t_{now} > t) \lor (\sigma_A \land H(r))`, where :math:`\sigma_A` is the signature generated by :math:`sk_A`, :math:`t_{now}` denotes the current blockchain time, and :math:`H(r)` is the output of a secure hash function :math:`H()` on input :math:`r` (SHA256 in Bitcoin).  
   * That is, only Alice can spend these coins:

      a. after time :math:`t` by providing her signature,
      b.  `anytime` by providing the preimage :math:`r` to :math:`H(r)` and her signature. 
   * The timelock can thereby be expressed as a UNIX timestamp or in Bitcoin blocks and can be (i) absolute (e.g. block height 500 000) or (ii) relative (e.g. 144 blocks after :math:`TX_A` is included in the Bitcoin blockchain)  
   * The transaction can have more outputs, but only the first will be checked in XFlash and considered for minting ``flashBTC`` tokens.

3. Alice waits for :math:`k` Bitcoin blocks.

4. Alice submits an SPV proof for :math:`T_A` to the :ref:`pool-sc` on Ethereum by calling the :ref:`deposit` function.


  a) The :ref:`pool-sc` calls :ref:`btc-relay` to (i) verify the inclusion proof for :math:`T_A` and (ii) to parse the transaction and extract the timelock duration from the first UTXO (and the target  `account` specified in the second `OP_RETURN` output).

  b) Mints 10 ``flashBTC`` token to Alice's Ethereum account `in the Lending Pool contract` by calling the :ref:`mint` function in the :ref:`treasury`.

Post-conditions
...............

Alice controls 10 ``flashBTC`` on Ethereum.


.. note:: There is likely no need for a complex crowdfunded minting on the Bitcoin side: we simply consider the entire XFlash balance as a liquidity pool. The more ``BTC`` you lock, the higher the fraction of the return you get, similar to a staking pool (we do not differentiate between "whose" ``flashBTC`` were actually used for flash loans).

Expiration
----------

When ``flashBTC`` are minted, they are tracked with their expiration time :math:`t`. When the current time :math:`t_{now}` is within a *security delay* :math:`\delta` of  expiration time :math:`t` the minted tokens expire.

  * The delay parameter :math:`\delta` is necessity since the block generation rates in Bitcoin and Ethereum can "desychronize", that is Bitcoin can speed up or slow down in relation to Ethereum due to mining variance. We can only avoid this if we have cross-chain relative timelocks (WIP).

Pre-conditions
..............

There are :math:`B` total `flashBTC` locked in the Lending Pool contract. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Protocol
.........

1. The :ref:`pool-sc` implicitly reduces the available balance for lending by the expired tokens. 

.. note:: A user can of course lock ``BTC`` in multiple stages, i.e., have multiple timelocked UTXOs in parallel. The simplest way to handle this on Ethereum is for a single *account* to control multiple balances in the :ref:`treasury`. This can be handled via an additional mapping tracking the timeouts for locked amounts of ``BTC`` per user.

Post-conditions
..............

There are only 90 ``flashBTC`` left in the smart contract, Alice has regained full control over her ``BTC`` and can withdraw any earned ``ETH`` fees from the smart contract.


FlashLoan
---------

Dave takes out a flash loan of ``flashBTC``.

.. note:: The total amount of available ``flashBTC`` is determine by the current time :math:`t_{now}`: only ``BTC`` locked on Bitcoin with a timelock :math:`t > t_{now} + \delta` count towards the total available ``flashBTC`` balance. 

Pre-conditions
..............

There are :math:`B` total `flashBTC` locked in the Lending Pool contract. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Dave wishes to lend an amount :math:`L` of ``flashBTC``.
For simplicity, let us assume ``B = L`` in this example.

Protocol
........

1. Dave creates and deploys a flash loan contract inheriting the :ref:`xflash-sc`. This contract needs to have two functions:

   a. The `flashExecute()` function in Dave's contract calls the :ref:`flash-borrow` function in the :ref:`pool-sc`. Dave will receive :math:`L` ``flashBTC`` after executing this function. In turn, the `flash-lend` function calls the second function in Dave's contract.

   b. The `executeActions()` function in Dave's contract receives the amount :math:`L` requested through `flashLoan()` and will execute actions specified by Dave. This function will also return the flash-loan by the end of the transaction including a fee (see also step 3).

2. Dave executes the flash loan by calling the `flashLoan()` function in his deployed XFlash contract. Note that Dave needs to specify all the actions to be executed in the deployed contract in step 1.

3. Dave's XFlash contract returns :math:`L` ``flashBTC`` to the smart contract and pays a fee :math:`f` in ``ETH``.

   * :math:`f` could thereby be a function of `L`, i.e., the higher the flash loan, the higher the fee :math:`f`. Reasoning: more volume should result in higher profits as it scales the system. The more liquidity is available, the more profit users can make on arbitrage trades. 
   * Alternatively, we could also charge a percentage of the arbitrage trade revenue, e.g. 1%. This would incentivize user to lock more BTC in the contract, as this allows higher profit margins on arbitrage trades and hence higher ROI on locked BTC.
   * Optionally, there can be a minimum fee on taking out flash loans (although this defeats one of the main benefits for borrowers - "pay on success"). Can be temporarily introduced if not enough users are locking BTC due to low profit margins to boost liquidity.

4. The smart contract distributes :math:`f` among Alice, Bob and Carol proportional to their contributions of ``flashBTC``.


Post-conditions
...............

The ``flashBTC`` balances remain unchanged. 
Dave has earned on an arbitrage trade on Ethereum and hence Alice, Bob, and Carol have earned a fraction of :math:`f` each. If Dave lost, no fees were paid (except if there is a minimum fee).



Announced Withdraw 
------------------

Alice announces that she wishes to withdraw her ``BTC`` from XFLASH, ``flashBTC`` balance is liquidated, fees are paid out and only then Alice recovers her ``BTC`` on Bitcoin using the hash pre-image / recovery secret ``r``. Alice can do this anytime while ``BTC`` are locked.

Pre-conditions
..............
There are :math:`B` total `flashBTC` locked in the XFlash contact. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Protocol
........

TODO

Post-conditions
...............
There are only 90 ``flashBTC`` left in the smart contract, Alice has regained full control over her ``BTC`` and can withdraw any earned ``ETH`` fees from the smart contract -- **before** time :mat:`t`.


Instant Withdraw
-----------------
Alice instantly withdraws her  ``BTC`` on Bitcoin by spending from the hash lock of the UTXO of :math:`T_A`. 

Pre-conditions
..............
There are :math:`B` total `flashBTC` locked in the XFlash contact. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Protocol
---------


Post-conditions
...............
There are only 90 ``flashBTC`` left in the smart contract, Alice has regained full control over her ``BTC`` **before** time :mat:`t`, **BUT** has lost the right to any earned fees. The fees are, e.g. distributed among other participants.



Extend 
------

Alice extends the timelock of her locked 10 BTC by renewing the timelock of :math:`TX_A` **before** :math:`t - \delta` by spending from the hash lock.

.. todo:: Write up. Comments below have already been incorporated. TODO: reduce number of on-chain ETH transactions.

.. warning:: Problem: we need to extend the timelock **before** time :math:`t`, but need to do this without enabling Alice to spend the BTC in a "burn" before time :math:`t`. TODO for @Alexei: figure out how to do this. 

.. note:: Dominik: That problem is solved when you don't have a burn function. If Alice does not extend, she is no longer part of the pool.

.. note:: Idea: ``burn`` transaction has an additional hash lock - revealed, anyone can use the hash-preimage to ``burn`` Alices *flashBTC* balance in the contract. The "burn" transaction thereby disburses any ETH fees earned by Alice among all honest participants. Caveat: Alice (and other BTC holders) must not be able to take out the ETH earning while the BTC lock is active - IMHO okay (similar to a savings contract). Nice side-effect: users can take out their coins **at any time** by spending from the hash lock on Bitcoin. If they announce this upfront, then they do not lose and earned fees (or only lose a fraction, to pay to the watchtower fees). **Main drawback**: needs some sort of watchtower watching the locked BTC account.

.. note:: Dominik: I think that puts a lot of burden on Alice and creates a dependency from Ethereum to Bitcoin. The beauty of the existing protocol was that there was no depdency from Ethereum to Bitcoin.

Pre-conditions
..............

There are :math:`B` total `flashBTC` locked in the XFlash contact. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Protocol
........

.. note:: The extend protocol is a variation of the minting protocol.

1. Alice spends her previously locked UTXO with expirey at :math:`t_p` (used in the :ref:`deposit` function) and creates a new timelocked UTXO, locking 10 ``BTC`` for period :math:`t`, e.g., 24h, by broadcasting (and hence including) a transaction :math:`T_A` on Bitcoin
 
   * :math:`T_A` has at least one output, which locks 10 ``BTC`` under the following condition: :math:`\sigma_A \land t_{now} > t`, where :math:`\sigma_A` is the signature generated by :math:`sk_A`.  
   * That is, only Alice can spend these coins after time :math:`t` (can be expressed in a UNIX timestamp or in Bitcoin blocks) and can be (i) absolute (e.g. block height 500 000) or (ii) relative (e.g. 144 blocks after :math:`TX_A` is included in the Bitcoin blockchain)  
   * The transaction can have more outputs, but only the first will be checked in XFlash and considered for minting ``flashBTC`` tokens.

2. Alice waits for :math:`k` Bitcoin blocks.

3. Alice submits an SPV proof for :math:`T_A` to the :ref:`pool-sc` on Ethereum by calling the :ref:`extend` function at time :math:`t_{submit}`.


  a) The :ref:`pool-sc` calls :ref:`btc-relay` to (i) verify the inclusion proof for :math:`T_A` and (ii) to parse the transaction and extract the timelock duration from the first UTXO (and the target  `account` specified in the second `OP_RETURN` output).

  b) Checks if the time of submitting the proof :math:`t_{submit}` is within the time of the initially locked ``flashBTC``, i.e. :math:`t_{submit} \leq t_{p} - \delta`.
  
    i) If at the time of submission Alice's previously minted ``flashBTC`` have not expired, Alice's previously minted ``flashBTC`` are extended from :math:`t_p` to time :math:`t`. 
    ii) Else, mints 10 ``flashBTC`` token to Alice's Ethereum account `in the Lending Pool contract` by calling the :ref:`mint` function in the :ref:`treasury`.



Post-conditions
...............
There balance of 100 ``flashBTC`` remains unchanged.


.. note:: We could introduce an `auction` protocol: if Alice takes out her BTC before the timelock expires, any user on a first-come-first-served basis can flag this (submitting Alice's secret or an SPV proof) and locking the equivalent amount of BTC to claim all fees earned by Alice. 
